import { ClassBuilder } from '../src/classes'
import { continuous, discrete } from '../src/generators'
import { instance } from '../src/instances'
import { all, obey } from '../src/validators'

test('readme examples work', () => {
  expect(() => {
    // Implicit

    interface Eq {
      equals(other: this): boolean
    }

    interface Addable {
      add(other: this): this
    }

    // Explicit

    const eq = new ClassBuilder('Eq')
      .withType<Eq>()
      .withLaws(
        obey(function reflexivity(x) {
          return x.equals(x)
        }),
      )
      .build()

    // We use a builder because it allows for type inferences that would not be
    // possible with simple parameters.

    // The class is named "Addable". this will be used in error messages.
    const addable = new ClassBuilder('Addable')
      // In this example, we are using TypeScript, so we need to specify the type
      // of the objects we want to test. This should be one or more interfaces, for
      // composability. If, and only if you are not using static typing, this may
      // be omitted.
      .withType<Addable>()
      .withParents(eq)
      // Next, we define the properties we expect our instances to have.
      // We'll start out by using the `all` function to say that, in order to
      // be an Addable, the constructor must obey all of the following laws
      // (not just any).
      .withLaws(
        all(
          // Using named functions is not necessary, but it helps to improve error
          // messages.
          // Each parameter to an `obey` function will be a value generated by the
          // Generator, which we will go over shortly. Your function may ask for as
          // many as it wants, and the system will take care of providing them.
          obey(function commutativity(x, y) {
            // `x` and `y` will have type `Addable & Eq`, as we defined above.
            const a = x.add(y)
            const b = y.add(x)

            return a.equals(b)
          }),
          obey(function associativity(x, y, z) {
            const a = x.add(y.add(z))
            const b = x.add(y).add(z)

            return a.equals(b)
          }),
        ),
      )
      .build()

    class Number {
      constructor(public readonly n: number) {}

      equals(other: Number): boolean {
        return this.n === other.n
      }

      add(other: Number): Number {
        return new Number(this.n + other.n)
      }
    }

    // You may ask for as many parameters as you want, and to each one will be
    // assigned a random number between 0 and 1 (inclusive).
    // From these numbers you may generate an instance of your constructor.
    // The name is used for error reporting.
    const gen1 = continuous('Number', (n) => new Number(n))

    // Note that, to increase the likelihood of catching edge cases, sometimes the
    // generated numbers will be all 0s or 1s.

    // Testing values will be sampled from the given array.
    const gen2 = discrete('Number', [
      new Number(0),
      new Number(1),
      new Number(2),
    ])

    // This method would be more useful if we had a finite number of possible
    // values, which is not the case.

    // will throw an Error if it fails
    instance(addable, gen1)
    instance(addable, gen2)

    instance(addable, gen1, { sampleSize: 10 })
    instance(addable, gen2, { sampleSize: 10 })
  }).not.toThrow()
})
